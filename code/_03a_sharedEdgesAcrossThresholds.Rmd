---
title: "Analyses to examine shared edges across z-thresholds"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Analyze how many edges are shared across thresholds


```{r, warning=FALSE, message=FALSE}
easypackages::libraries(c("here","ggplot2","readxl","e1071"))

rootpath = "/Users/mlombardo/Dropbox/euaims/data/adir"
datapath = here("data")
codepath = here("code")
resultpath = here("results")
plotpath = here("plots")

adjmatpath = file.path(resultpath,"anova_allconnections","adj_mat")
```

## Compute number of shared edges

```{r, warning=FALSE, message=FALSE}
z_thresh = c(0.5, 0.6, 0.7, 0.8, 0.9, 1)
nedges = 171

# pre-allocate res data frame so that I can save the number of shared edges across subtypes
res = data.frame(z = z_thresh, 
                 shared_edges_sign = numeric(length = length(z_thresh)),
                 shared_edges_unsign = numeric(length = length(z_thresh)))
rownames(res) = z_thresh

# pre-allocate a list to save edges on the lower triangle
edge_res = list(z0.5_1 = numeric(length = nedges), 
     z0.6_1 = numeric(length = nedges), 
     z0.7_1 = numeric(length = nedges), 
     z0.8_1 = numeric(length = nedges), 
     z0.9_1 = numeric(length = nedges), 
     z1_1 = numeric(length = nedges),
     z0.5_2 = numeric(length = nedges), 
     z0.6_2 = numeric(length = nedges), 
     z0.7_2 = numeric(length = nedges), 
     z0.8_2 = numeric(length = nedges), 
     z0.9_2 = numeric(length = nedges), 
     z1_2 = numeric(length = nedges))

# loop over z-thresholds
for (i in 1:length(z_thresh)){

  z = z_thresh[i]
  
  # read in excel sheets
  df1 = read_excel(file.path(adjmatpath, sprintf("adj_mat_z%s.xlsx",as.character(z))), sheet = "SC=RRB vs TD")
  df2 = read_excel(file.path(adjmatpath, sprintf("adj_mat_z%s.xlsx",as.character(z))), sheet = "SC>RRB vs TD")
  
  # get binary matrices of negative sign and positive sign connections
  neg_bin1 = df1[,2:ncol(df1)] == -1
  pos_bin1 = df1[,2:ncol(df1)] == 1
  # get a binary matrix that doesn't care about the sign
  unsigned_bin1 = df1[,2:ncol(df1)] != 0
  
  # get binary matrices of negative sign and positive sign connections
  neg_bin2 = df2[,2:ncol(df2)] == -1
  pos_bin2 = df2[,2:ncol(df2)] == 1
  # get a binary matrix that doesn't care about the sign
  unsigned_bin2 = df2[,2:ncol(df2)] != 0
  
  # get overlap between matrices
  overlap_neg = neg_bin1 & neg_bin2
  overlap_pos = pos_bin1 & pos_bin2
  overlap_signed = overlap_neg | overlap_pos
  
  overlap_1 = neg_bin1 | pos_bin1
  overlap_2 = neg_bin2 | pos_bin2
  overlap_unsigned = unsigned_bin1 & unsigned_bin2
  
  # save into res
  res[z,"shared_edges_sign"] = sum(overlap_signed)/2
  res[z,"shared_edges_unsign"] = sum(overlap_unsigned)/2
  
  # extract lower triangle and save to list
  lmask = lower.tri(neg_bin1, diag = FALSE)
  edge_res[[sprintf("z%s_1",as.character(z))]] = overlap_1[lmask]
  edge_res[[sprintf("z%s_2",as.character(z))]] = overlap_2[lmask]
} # for i

# show shared edges across subtypes when keeping the sign or not (unsigned)
res

```

